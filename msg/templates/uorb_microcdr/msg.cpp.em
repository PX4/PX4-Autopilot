@###############################################
@#
@# PX4 ROS compatible message source code
@# generation for C++
@#
@# EmPy template for generating <msg>.h files
@# Based on the original template for ROS
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - search_path (dict) search paths for genmsg
@###############################################
/****************************************************************************
 *
 *   Copyright (C) 2013-2021 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/* Auto-generated by genmsg_cpp from file @file_name_in */

@{
import genmsg.msgs

from px_generate_uorb_topic_helper import * # this is in Tools/

uorb_struct = '%s_s'%spec.short_name
topic_name = spec.short_name
}@

#include <px4_platform_common/px4_config.h>
#include <ucdr/microcdr.h>
#include <uORB/topics/@(topic_name).h>
#include <uORB_microcdr/topics/@(topic_name).h>

@#################################################
@# Searching for serialize function per each field
@#################################################
@{

def print_info(field):
    print("type: ", field.type, "name: ", field.name, "base_type: ", \
          field.base_type, "field.is_array:", ('0', '1')[field.is_array], " array_len: ", field.array_len, \
          "is_builtin:", ('0', '1')[field.is_builtin], "is_header:", ('0', '1')[field.is_header])

def print_level_info(fields):
    for field in fields:
        print_info(field)
        if (not field.is_builtin):
            print("\n")
            children_fields = get_children_fields(field.base_type, search_path)
            print_level_info(children_fields)
            print("\n")

def walk_through_parsed_fields():
    print_level_info(spec.parsed_fields())

def get_serialization_type_name(type_name):
    if type_name in type_serialize_map:
        return type_serialize_map[type_name]
    else:
        raise Exception("Type {0} not supported, add to type_serialize_map!".format(type_name))

def add_serialize_functions(fields, scope_name):
    for field in fields:
        if (not field.is_header):
            if (field.is_builtin):
                if (not field.is_array):
                    print("    ucdr_serialize_" + str(get_serialization_type_name(field.type)) + "(writer, input->" + scope_name+str(field.name) + ");")
                else:
                    print("    ucdr_serialize_array_" + str(get_serialization_type_name(field.base_type)) + "(writer, input->" + scope_name+str(field.name) + ", " + str(field.array_len) + ");")
            else:
                name = field.name
                children_fields = get_children_fields(field.base_type, search_path)
                if (scope_name):  name = scope_name + name
                if (not field.is_array):
                    add_serialize_functions(children_fields, name + '.')
                else:
                    for i in range(field.array_len):
                        add_serialize_functions(children_fields, name + ('[%d].' %i))

def add_deserialize_functions(fields, scope_name):
    for field in fields:
        if (not field.is_header):
            if (field.is_builtin):
                if (not field.is_array):
                    print("    ucdr_deserialize_" + str(get_serialization_type_name(field.type)) + "(reader, &output->" + scope_name+str(field.name) + ");")
                else:
                    print("    ucdr_deserialize_array_" + str(get_serialization_type_name(field.base_type)) + "(reader, output->" + scope_name+str(field.name) + ", " + str(field.array_len) + ");")
            else:
                name = field.name
                children_fields = get_children_fields(field.base_type, search_path)
                if (scope_name):  name = scope_name + name
                if (not field.is_array):
                    add_deserialize_functions(children_fields, name + '.')
                else:
                    for i in range(field.array_len):
                        add_deserialize_functions(children_fields, name + ('[%d].' %i))

def add_code_to_serialize():
    add_serialize_functions(spec.parsed_fields(), "")

def add_code_to_deserialize():
    add_deserialize_functions(spec.parsed_fields(), "")
}@

void serialize_@(topic_name)(ucdrBuffer *writer, const struct @(uorb_struct) *input, char *output, uint32_t *length)
{
    if (nullptr == writer || nullptr == input || nullptr == output || nullptr == length)
	return;

    ucdr_reset_buffer(writer);

@add_code_to_serialize()
    (*length) = ucdr_buffer_length(writer);
}

void deserialize_@(topic_name)(ucdrBuffer *reader, struct @(uorb_struct) *output, const char *input)
{
    if (nullptr == reader || nullptr == output || nullptr == input)
	return;

    ucdr_reset_buffer(reader);

@add_code_to_deserialize()
}
