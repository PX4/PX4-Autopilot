/****************************************************************************
 *
 *   Copyright (c) 2012-2018 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mixer_multirotor.cpp
 *
 * Multi-rotor mixers.
 */


#include "MultirotorMixer.hpp"

#include <float.h>
#include <cstring>
#include <cstdio>

#include <mathlib/mathlib.h>


/// Use this macro to select the type of control
#define YAW_TILT_CONTROLLED



#ifndef YAW_TILT_CONTROLLED
/// This file is generated by the px_generate_mixers.py script which is invoked during the build process
#include <mixer_multirotor.generated.h>
#else
/// This file is generated by the px_generate_mixers.py script which is invoked during the build process
#include <mixer_multirotor_tilt.generated.h>
#endif /* MIXER_MULTIROTOR_USE_MOCK_GEOMETRY */


//#define debug(fmt, args...)	do { } while(0)
#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	syslog(fmt "\n", ##args)

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, MultirotorGeometry geometry) :
    MultirotorMixer(control_cb, cb_handle, _config_index[(int)geometry], _config_geometries_index[(int)geometry], _config_rotor_count[(int)geometry])
{
}

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, const Rotor *rotors, const Geometry *geo,
                 unsigned rotor_count) :
    Mixer(control_cb, cb_handle),
    _rotor_count(rotor_count),  /// Nb of rotors
    _rotors(rotors),            /// Pinv allocation matrix
    _geometry(geo),             /// Geometric position of the rotors
    _outputs_prev(new float[_rotor_count]),
    _tmp_array(new float[_rotor_count])
{
    for (unsigned i = 0; i < _rotor_count; ++i) {
        _outputs_prev[i] = 0.f;
    }

    /// Get the px4 parameters  - if param_get/find brings errors at build time then be sure to replace src/lib/parameters/CMakeLists.txt by src/lib/mixer/MultirotorMixer/geometries/tools/multicopter/CMakeLists_parameters.txt
    param_get(param_find("MC_MASS"), &_param_mc_mass);
    param_get(param_find("MC_INERTIA_XX"), &_param_mc_Ixx);
    param_get(param_find("MC_INERTIA_YY"), &_param_mc_Iyy);
    param_get(param_find("MC_INERTIA_ZZ"), &_param_mc_Izz);

    param_get(param_find("MC_CT_LIFT"), &_param_mc_Ct);
    param_get(param_find("MC_CM_DRAG"), &_param_mc_Cm);

    param_get(param_find("MC_ROLLRATE_K"), &_param_mc_max_angular_acceleration_roll);
    _param_mc_max_angular_acceleration_roll=1/_param_mc_max_angular_acceleration_roll;
    param_get(param_find("MC_PITCHRATE_K"), &_param_mc_max_angular_acceleration_pitch);
    _param_mc_max_angular_acceleration_pitch=1/_param_mc_max_angular_acceleration_pitch;
    param_get(param_find("MC_YAWRATE_K"), &_param_mc_max_angular_acceleration_yaw);
    _param_mc_max_angular_acceleration_yaw=1/_param_mc_max_angular_acceleration_yaw;

    /// The angular acceleration control inputs are previously constraint beetween -1 and 1 by dividing by the maximal angular acceleration
    /// So we need to multiply them by the maximal angular acceleration to get SI units
    _param_mc_Ixx*=_param_mc_max_angular_acceleration_roll;
    _param_mc_Iyy*=_param_mc_max_angular_acceleration_pitch;
    _param_mc_Izz*=_param_mc_max_angular_acceleration_yaw;


    /// Compute the coeficients needed to ensure the right servo motors angle for the tilt
    if(param_find("PWM_TILT_MAX1")!=PARAM_INVALID)
    {
        int _param_mc_pwm_tilt_max[2];
        int _param_mc_pwm_tilt_min[2];
        float _param_mc_ang_tilt_min;
        float _param_mc_ang_tilt_max;
        int _param_mc_pwm_max = 2000;
        int _param_mc_pwm_min = 1000;
        param_get(param_find("PWM_MAX"), &_param_mc_pwm_max);
        param_get(param_find("PWM_MAX"), &_param_mc_pwm_max);
        param_get(param_find("PWM_TILT_MAX1"), _param_mc_pwm_tilt_max);
        param_get(param_find("PWM_TILT_MAX2"), _param_mc_pwm_tilt_max+1);
        param_get(param_find("PWM_TILT_MIN1"), _param_mc_pwm_tilt_min);
        param_get(param_find("PWM_TILT_MIN2"), _param_mc_pwm_tilt_min+1);

        param_get(param_find("ANG_TILT_MIN"), &_param_mc_ang_tilt_min);
        param_get(param_find("ANG_TILT_MAX"), &_param_mc_ang_tilt_max);
        for(int i =0; i<2; i++)
        {
            m_alpha_min[i]=(2.0f*_param_mc_pwm_tilt_min[i]-(_param_mc_pwm_max+_param_mc_pwm_min))/(_param_mc_pwm_max-_param_mc_pwm_min);
            m_alpha_max[i]=(2.0f*_param_mc_pwm_tilt_max[i]-(_param_mc_pwm_max+_param_mc_pwm_min))/(_param_mc_pwm_max-_param_mc_pwm_min);
            m_alpha_a[i] = (-1-1)/(_param_mc_ang_tilt_min-_param_mc_ang_tilt_max);
            m_alpha_b[i] = -1 - m_alpha_a[i]*_param_mc_ang_tilt_min;
        }
    }

    _allocation_matrix = (float *)_rotors;

}

MultirotorMixer::~MultirotorMixer()
{
    delete[] _outputs_prev;
    delete[] _tmp_array;
}

MultirotorMixer *
MultirotorMixer::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)
{
    MultirotorGeometry geometry = MultirotorGeometry::MAX_GEOMETRY;
    char geomname[16];

    /* enforce that the mixer ends with a new line */
    if (!string_well_formed(buf, buflen)) {
        return nullptr;
    }

    if (sscanf(buf, "R: %15s", geomname) != 1) {
        debug("multirotor parse failed on '%s'", buf);
        return nullptr;
    }

    buf = skipline(buf, buflen);

    if (buf == nullptr) {
        debug("no line ending, line is incomplete");
        return nullptr;
    }

    debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

    for (MultirotorGeometryUnderlyingType i = 0; i < (MultirotorGeometryUnderlyingType)MultirotorGeometry::MAX_GEOMETRY;
         i++) {
        if (!strcmp(geomname, _config_key[i])) {
            geometry = (MultirotorGeometry)i;
            break;
        }
    }

    if (geometry == MultirotorGeometry::MAX_GEOMETRY) {
        debug("unrecognised geometry '%s'", geomname);
        return nullptr;
    }

    debug("adding multirotor mixer '%s'", geomname);

    return new MultirotorMixer(control_cb, cb_handle, geometry);
}

float
MultirotorMixer::compute_desaturation_gain(const float *desaturation_vector, const float *outputs,
        saturation_status &sat_status, float min_output, float max_output) const
{
    float k_min = 0.f;
    float k_max = 0.f;

    for (unsigned i = 0; i < _rotor_count; i++) {
        // Avoid division by zero. If desaturation_vector[i] is zero, there's nothing we can do to unsaturate anyway
        if (fabsf(desaturation_vector[i]) < FLT_EPSILON) {
            continue;
        }

        if (outputs[i] < min_output) {
            float k = (min_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_neg = true;
        }

        if (outputs[i] > max_output) {
            float k = (max_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_pos = true;
        }
    }

    // Reduce the saturation as much as possible
    return k_min + k_max;
}

void
MultirotorMixer::minimize_saturation(const float *desaturation_vector, float *outputs,
                     saturation_status &sat_status, float min_output, float max_output, bool reduce_only) const
{
    float k1 = compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    if (reduce_only && k1 > 0.f) {
        return;
    }

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k1 * desaturation_vector[i];
    }

    // Compute the desaturation gain again based on the updated outputs.
    // In most cases it will be zero. It won't be if max(outputs) - min(outputs) > max_output - min_output.
    // In that case adding 0.5 of the gain will equilibrate saturations.
    float k2 = 0.5f * compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k2 * desaturation_vector[i];
    }
}


void
MultirotorMixer::mix_airmode_disabled(float moment_roll, float moment_pitch, float moment_yaw, float thrust, float *squared_rotor_spd)
{
    /// In this function you can compute the relation between the moment/thrust and the rotor squared speed.
    /// All the variable are in SI units


    /// ######### PX4 original computation ###########
    /// Almost equivalent to a matrix multiplication between the pseudo inverse of the allocation matrix and the moment/thrust vector.

    /// never allow to increase the thrust to unsaturate a motor
    /// Mix without yaw
    for (unsigned i = 0; i < _rotor_count; i++) {

        squared_rotor_spd[i] = moment_roll * _rotors[i].rotor_roll_allocation_coeff +
                 moment_pitch * _rotors[i].rotor_pitch_allocation_coeff -
                 thrust * _rotors[i].thrust_allocation_coeff;
        // Thrust will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // only reduce thrust
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _param_mc_min_speed2, _param_mc_max_speed2, true);

    // Reduce roll/pitch acceleration if needed to unsaturate
    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_roll_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _param_mc_min_speed2, _param_mc_max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_pitch_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _param_mc_min_speed2, _param_mc_max_speed2);

    // Mix yaw independently
    mix_yaw(moment_yaw, squared_rotor_spd);

}

void MultirotorMixer::mix_yaw(float yaw, float *outputs)
{
    // Add yaw to outputs
    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += yaw * _rotors[i].rotor_yaw_allocation_coeff;

        // Yaw will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].rotor_yaw_allocation_coeff;
    }

    // Change yaw acceleration to unsaturate the outputs if needed (do not change roll/pitch),
    // and allow some yaw response at maximum thrust
    minimize_saturation(_tmp_array, outputs, _saturation_status, _param_mc_min_speed2, _param_mc_max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // reduce thrust only
    minimize_saturation(_tmp_array, outputs, _saturation_status, _param_mc_min_speed2, _param_mc_max_speed2, true);
}

float
MultirotorMixer::g(float x)
{
    return ((x<=float(M_PI)/4)? float(1/cos(x))
                       : float(pow(cos(x),4)/pow(cos(M_PI/4),5)) );
}

void
MultirotorMixer::mix_yaw_tilt_controlled(float moment_roll, float moment_pitch, float moment_yaw, float thrust, float mean_tilt, float* delta_tilt, float *squared_rotor_spd)
{
    float T[4] = {-g(mean_tilt)/(_geometry[0].j*_param_mc_Ct) * moment_roll,
                  g(mean_tilt)/(_geometry[0].i*_param_mc_Ct) * moment_pitch,
                  0,
                  1/_param_mc_Ct * thrust };

    // Mix without yaw
    for (unsigned i = 0; i < _rotor_count; i++) {
        squared_rotor_spd[i] =  0.f;
        for(int j = 0; j <4; j++)
            squared_rotor_spd[i] += _allocation_matrix[i*4+j]  * T[j];

        _tmp_array[i] = _rotors[i].thrust_allocation_coeff; // Thrust will be used to unsaturate if needed
    }

    //Compute angle tilt to control the yaw
    float sum1=0;
    for(unsigned i =0;i<_rotor_count;i++)
        sum1+= _geometry[i].dir*squared_rotor_spd[i];       // \sum_{i=1}^{4}(-1)^i.\Bar{\omega}_i^2
        //          |                  |
        //          |                  '-> rotor squared rotation speed <=> \Bar{\omega}_i^2
        //          '-> Counter Clock Wise rotation: 1   Clock Wise rotation: -1
    float sum2=fabsf(_geometry[0].j)*_param_mc_mass*9.81f;

    float max_ang =2.0f*float(M_PI)/180.f;//degree
    debug("mg: %f g: %f",double(sum2), double(g(mean_tilt)));

    *delta_tilt = -math::constrain(g(mean_tilt)*(moment_yaw)/sum2, -max_ang, max_ang);


}

unsigned
MultirotorMixer::mix(float *output_sent_to_driver, unsigned space)
{
    //Only one array is used but for readibility we use different name depending on the process step.
    float *squared_rotor_spd = output_sent_to_driver;
    float *rotor_spd = output_sent_to_driver;

    if (space < _rotor_count) {
        return 0;
    }
    //debug("%f %f %f %f",double(_param_mc_Ixx), double(_param_mc_Iyy),double(_param_mc_Izz), double(2.0f*_param_mc_mass*9.81f));


    float torque_roll    = 4*_param_mc_Ixx  * get_control(0, 0);
    float torque_pitch   = 2.5f*_param_mc_Iyy  * get_control(0, 1);
    float torque_yaw     = _param_mc_Izz  * get_control(0, 2);
    //        |              |           |
    //        |              |           '-> angular acceleretion setpoint
    //        |              '-> Inertia of the drone
    //        '-> Torques setpoint
    float thrust  = 2.0f*_param_mc_mass*9.81f  * get_control(0, 3);

    //debug("cmd r%f p%f y%f t%f",double(torque_roll), double(torque_pitch),double(torque_yaw), double(torque_yaw));





    // clean out class variable used to capture saturation
    _saturation_status.value = 0;

    // Do the mixing using the strategy given by the current Airmode configuration
#ifdef YAW_TILT_CONTROLLED
    float *tilt_motor_pos = output_sent_to_driver+_rotor_count;
    float mean_tilt=0;//get_control(0, 2);
    float delta_tilt=0;
    mix_yaw_tilt_controlled(torque_roll, torque_pitch, torque_yaw, thrust, mean_tilt, &delta_tilt, squared_rotor_spd);
#else
    mix_airmode_disabled(torque_roll, torque_pitch, torque_yaw, thrust, squared_rotor_spd);
#endif


    //By aightech: transform the rotor speed into pwm
    // output_sent_to_driver has to be between -1 and 1.
    //When -1, the duty cycle sent to the motor is 0.
    //When 0, , the duty cycle sent to the motor is 0.5.
    //When 1, the duty cycle sent to the motor is 1.
    // THIS IS WERE WE HAVE CONTROL OVER THE DUTY CYCLE
    // Then it is processed by the drivers.
    for (unsigned i = 0; i < _rotor_count; i++)
    {
        //By aightech:: root squared the rotor speed.
        rotor_spd[i] = sqrt(math::constrain(squared_rotor_spd[i],0.0f,fabsf(squared_rotor_spd[i])));
        //debug("spd:%d %f ",i,double(rotor_spd[i]));
        float A=1379.5;
        float B=-89.f;
        output_sent_to_driver[i] = math::constrain(2.0f*rotor_spd[i]/A-1.0f -2*B/A ,-1.0f,1.0f);//math::constrain((rotor_spd[i]/motor_constant_in_rad_sec_per_volt/battery_voltage)*2.0f-1.0f,-1.0f,1.0f);
        //debug("val:%d %f ",i,double(output_sent_to_driver[i]));
    }

#ifdef YAW_TILT_CONTROLLED
    for(int i =0; i<2; i++)
    {
        float tilt = delta_tilt;// + (-1+i*2)*mean_tilt;
        //debug("tilt:%d %f ",i,double(tilt));

        float alpha = m_alpha_a[i]*tilt+m_alpha_b[i];
        tilt_motor_pos[i]= math::constrain(alpha*(m_alpha_max[i]-m_alpha_min[i])/2.0f+(m_alpha_min[i]+m_alpha_max[i])/2.0f,m_alpha_min[i], m_alpha_max[i]); // output the tilt angle with the right orientation depending of right/left tilt motor
        //debug("%d %f %f %f",i,double(m_alpha_min[i]),double(tilt_motor_pos[i]),double(m_alpha_max[i]));
    }

    return _rotor_count+2; // each rotors has been mixed + each tilt motors
#else
    return _rotor_count; // each rotors has been mixed + each tilt motors
#endif
}
