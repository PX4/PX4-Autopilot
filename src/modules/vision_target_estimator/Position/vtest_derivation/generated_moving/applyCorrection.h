// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <matrix/math.hpp>

namespace sym
{

/**
 * This function was autogenerated from a symbolic function. Do not modify by hand.
 *
 * Symbolic function: applyCorrection
 *
 * Args:
 *     state: Matrix51
 *     cov: Matrix55
 *     K: Matrix51
 *     innov: Scalar
 *     S: Scalar
 *
 * Outputs:
 *     state_new: Matrix51
 *     cov_new: Matrix55
 */
template <typename Scalar>
void Applycorrection(const matrix::Matrix<Scalar, 5, 1> &state,
		     const matrix::Matrix<Scalar, 5, 5> &cov, const matrix::Matrix<Scalar, 5, 1> &K,
		     const Scalar innov, const Scalar S,
		     matrix::Matrix<Scalar, 5, 1> *const state_new = nullptr,
		     matrix::Matrix<Scalar, 5, 5> *const cov_new = nullptr)
{
	// Total ops: 100

	// Input arrays

	// Intermediate terms (14)
	const Scalar _tmp0 = 2 * S;
	const Scalar _tmp1 = K(0, 0) * _tmp0;
	const Scalar _tmp2 =
		-Scalar(0.5) * K(1, 0) * _tmp1 + Scalar(0.5) * cov(0, 1) + Scalar(0.5) * cov(1, 0);
	const Scalar _tmp3 =
		-Scalar(0.5) * K(2, 0) * _tmp1 + Scalar(0.5) * cov(0, 2) + Scalar(0.5) * cov(2, 0);
	const Scalar _tmp4 = K(3, 0) * _tmp0;
	const Scalar _tmp5 =
		-Scalar(0.5) * K(0, 0) * _tmp4 + Scalar(0.5) * cov(0, 3) + Scalar(0.5) * cov(3, 0);
	const Scalar _tmp6 = K(4, 0) * _tmp0;
	const Scalar _tmp7 =
		-Scalar(0.5) * K(0, 0) * _tmp6 + Scalar(0.5) * cov(0, 4) + Scalar(0.5) * cov(4, 0);
	const Scalar _tmp8 =
		-Scalar(0.5) * K(1, 0) * K(2, 0) * _tmp0 + Scalar(0.5) * cov(1, 2) + Scalar(0.5) * cov(2, 1);
	const Scalar _tmp9 =
		-Scalar(0.5) * K(1, 0) * _tmp4 + Scalar(0.5) * cov(1, 3) + Scalar(0.5) * cov(3, 1);
	const Scalar _tmp10 =
		-Scalar(0.5) * K(1, 0) * _tmp6 + Scalar(0.5) * cov(1, 4) + Scalar(0.5) * cov(4, 1);
	const Scalar _tmp11 =
		-Scalar(0.5) * K(2, 0) * _tmp4 + Scalar(0.5) * cov(2, 3) + Scalar(0.5) * cov(3, 2);
	const Scalar _tmp12 =
		-Scalar(0.5) * K(2, 0) * _tmp6 + Scalar(0.5) * cov(2, 4) + Scalar(0.5) * cov(4, 2);
	const Scalar _tmp13 =
		-Scalar(0.5) * K(3, 0) * _tmp6 + Scalar(0.5) * cov(3, 4) + Scalar(0.5) * cov(4, 3);

	// Output terms (2)
	if (state_new != nullptr) {
		matrix::Matrix<Scalar, 5, 1> &_state_new = (*state_new);

		_state_new(0, 0) = K(0, 0) * innov + state(0, 0);
		_state_new(1, 0) = K(1, 0) * innov + state(1, 0);
		_state_new(2, 0) = K(2, 0) * innov + state(2, 0);
		_state_new(3, 0) = K(3, 0) * innov + state(3, 0);
		_state_new(4, 0) = K(4, 0) * innov + state(4, 0);
	}

	if (cov_new != nullptr) {
		matrix::Matrix<Scalar, 5, 5> &_cov_new = (*cov_new);

		_cov_new(0, 0) = -Scalar(0.5) * std::pow(K(0, 0), Scalar(2)) * _tmp0 + Scalar(1.0) * cov(0, 0);
		_cov_new(1, 0) = _tmp2;
		_cov_new(2, 0) = _tmp3;
		_cov_new(3, 0) = _tmp5;
		_cov_new(4, 0) = _tmp7;
		_cov_new(0, 1) = _tmp2;
		_cov_new(1, 1) = -Scalar(0.5) * std::pow(K(1, 0), Scalar(2)) * _tmp0 + Scalar(1.0) * cov(1, 1);
		_cov_new(2, 1) = _tmp8;
		_cov_new(3, 1) = _tmp9;
		_cov_new(4, 1) = _tmp10;
		_cov_new(0, 2) = _tmp3;
		_cov_new(1, 2) = _tmp8;
		_cov_new(2, 2) = -Scalar(0.5) * std::pow(K(2, 0), Scalar(2)) * _tmp0 + Scalar(1.0) * cov(2, 2);
		_cov_new(3, 2) = _tmp11;
		_cov_new(4, 2) = _tmp12;
		_cov_new(0, 3) = _tmp5;
		_cov_new(1, 3) = _tmp9;
		_cov_new(2, 3) = _tmp11;
		_cov_new(3, 3) = -Scalar(0.5) * std::pow(K(3, 0), Scalar(2)) * _tmp0 + Scalar(1.0) * cov(3, 3);
		_cov_new(4, 3) = _tmp13;
		_cov_new(0, 4) = _tmp7;
		_cov_new(1, 4) = _tmp10;
		_cov_new(2, 4) = _tmp12;
		_cov_new(3, 4) = _tmp13;
		_cov_new(4, 4) = -Scalar(0.5) * std::pow(K(4, 0), Scalar(2)) * _tmp0 + Scalar(1.0) * cov(4, 4);
	}
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
