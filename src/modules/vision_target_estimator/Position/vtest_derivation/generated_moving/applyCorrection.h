// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <matrix/math.hpp>

namespace sym
{

/**
 * This function was autogenerated from a symbolic function. Do not modify by hand.
 *
 * Symbolic function: applyCorrection
 *
 * Args:
 *     state: Matrix51
 *     cov: Matrix55
 *     K: Matrix51
 *     innov: Scalar
 *     S: Scalar
 *
 * Outputs:
 *     state_new: Matrix51
 *     cov_new: Matrix55
 */
template <typename Scalar>
void Applycorrection(const matrix::Matrix<Scalar, 5, 1> &state,
		     const matrix::Matrix<Scalar, 5, 5> &cov, const matrix::Matrix<Scalar, 5, 1> &K,
		     const Scalar innov, const Scalar S,
		     matrix::Matrix<Scalar, 5, 1> *const state_new = nullptr,
		     matrix::Matrix<Scalar, 5, 5> *const cov_new = nullptr)
{
	// Total ops: 0

	// Input arrays

	// Intermediate terms (0)

	// Output terms (2)
	if (state_new != nullptr) {
		matrix::Matrix<Scalar, 5, 1> &_state_new = (*state_new);

		_state_new(0, 0) = K(0, 0) * innov + state(0, 0);
		_state_new(1, 0) = K(1, 0) * innov + state(1, 0);
		_state_new(2, 0) = K(2, 0) * innov + state(2, 0);
		_state_new(3, 0) = K(3, 0) * innov + state(3, 0);
		_state_new(4, 0) = K(4, 0) * innov + state(4, 0);
	}

	if (cov_new != nullptr) {
		matrix::Matrix<Scalar, 5, 5> &_cov_new = (*cov_new);

		for (int r = 0; r < 5; r++) {
			for (int c = 0; c < 5; c++) {
				_cov_new(r, c) = cov(r, c) - K(r, 0) * K(c, 0) * S;
			}
		}
	}
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
