#!/usr/bin/env python3
import re
from pathlib import Path
import json

"""
Parses mode requirements in https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/commander/ModeUtil/mode_requirements.cpp
The structure can then be used to generate docs.
This is mostly generated by ChatGPT, with some extensive prompting.

"""

# Placeholder for the source file path
# Since I cannot read your file system, I'll assume this path is correct
# and modify the code with the regex logic.
SRC = Path("../../src/modules/commander/ModeUtil/mode_requirements.cpp")

# Regex to find setRequirement(mode, requirement)
SET_REQ = re.compile(r"setRequirement\(\s*([^,]+)\s*,\s*([^)]+)\)")

# Original Regex to match the start of the specific if condition
VEH_IF_START = re.compile(
    r'if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*\{',
    re.MULTILINE,
)

# New Combined Regex Patterns
# 1. Pattern for specific IF-ELSE block (Group 1: Type, Group 2: If Body, Group 3: Else Body)
IF_ELSE_VEH = re.compile(
    # Start of the specific IF
    r'(?:^|\s)if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*'
    # IF Body (non-greedy)
    r'\{([\s\S]*?)\}\s*'
    # ELSE part
    r'else\s*\{([\s\S]*?)\}',
    re.MULTILINE | re.IGNORECASE
)

# 2. Pattern for specific STANDALONE IF block (Group 1: Type, Group 2: If Body)
IF_STANDALONE_VEH = re.compile(
    # Start of the specific IF
    r'(?:^|\s)if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*'
    # IF Body (non-greedy)
    r'\{([\s\S]*?)\}',
    re.MULTILINE | re.IGNORECASE
)


def extract_conditional_blocks(text):
    """
    Extracts specific if { … } blocks and optional else { … } following them
    using a two-step regex strategy.

    Returns:
        blocks: list of tuples (vehicle_type, if_block_text, else_block_text)
        remaining: text with conditional blocks removed (replaced by spaces)
    """
    blocks = []
    
    # --- 1. Find and process IF-ELSE blocks (Priority 1) ---
    
    # Use finditer to get matches and their spans to remove them later
    if_else_matches = list(IF_ELSE_VEH.finditer(text))
    
    # Process matches in reverse order to safely modify the code string
    for match in reversed(if_else_matches):
        vehicle_type = match.group(1)
        if_body = match.group(2).strip()
        else_body = match.group(3).strip()
        
        # else_block is not None here, but we pass None for consistency in the loop below
        blocks.append((vehicle_type, if_body, else_body))
        
        # Replace the matched block with whitespace to "remove" it
        start, end = match.span()
        text = text[:start] + ' ' * (end - start) + text[end:]

    # Reverse the list back to the original order of appearance
    blocks.reverse()


    # --- 2. Find and process STANDALONE IF blocks (Priority 2) ---

    # Note: text now contains only the code that was NOT part of an if-else block
    standalone_matches = list(IF_STANDALONE_VEH.finditer(text))
    
    # Process matches in reverse order
    for match in reversed(standalone_matches):
        vehicle_type = match.group(1)
        if_body = match.group(2).strip()
        
        # else_block is explicitly None for standalone ifs
        blocks.append((vehicle_type, if_body, None))
        
        # Replace the matched block with whitespace to "remove" it
        start, end = match.span()
        text = text[:start] + ' ' * (end - start) + text[end:]

    # Reverse the standalone block list back to the original order of appearance
    blocks[len(if_else_matches):].reverse()

    remaining = text
    return blocks, remaining


def parse_set_requirements(block_text):
    """
    Parse all setRequirement() calls in a text segment.
    Returns: dict of mode -> set(requirements)
    """
    results = {}
    for mode, req in SET_REQ.findall(block_text):
        mode = mode.strip().replace('vehicle_status_s::', '')
        req = req.strip().replace('flags.', '')
        results.setdefault(mode, set()).add(req)
    return results

def parse_requirements():
    # Attempt to read the file content
    try:
        text = SRC.read_text()
    except FileNotFoundError:
        print(f"Error: Source file not found at {SRC.resolve()}")
        # Returning an empty result for demonstration if file not found
        # In a real setup, you might want to raise the exception.
        return {} 

    # Extract getModeRequirements() body
    m = re.search(r"getModeRequirements\s*\([^)]*\)\s*\{(.*)\}", text, re.S)
    if not m:
        raise RuntimeError("Could not find getModeRequirements() body")
    body = m.group(1)

    # Extract conditional blocks using the new regex logic
    blocks, remaining = extract_conditional_blocks(body)

    # Determine all vehicle types seen in the code
    # Note: The code assumes all vehicle types relevant to the final output are
    # covered by the blocks and not just implicit.
    all_vehicle_types = set(vtype for vtype, _, _ in blocks)

    vehicle_modes = {vtype: {} for vtype in all_vehicle_types}

    # 1️⃣ Process conditional blocks
    for vtype, if_block, else_block in blocks:
        # Assign if-block requirements to the specified vehicle type
        reqs_if = parse_set_requirements(if_block)
        for mode, reqs in reqs_if.items():
            vehicle_modes[vtype].setdefault(mode, set()).update(reqs)

        # Assign else-block requirements to all other vehicle types
        if else_block:
            reqs_else = parse_set_requirements(else_block)
            # Find vehicle types NOT explicitly mentioned in the IF condition
            other_types = all_vehicle_types - {vtype}
            
            # The structure of the code assumes that 'else' applies to all other
            # vehicle types that appear in other blocks.
            for ot in other_types:
                for mode, reqs in reqs_else.items():
                    vehicle_modes[ot].setdefault(mode, set()).update(reqs)

    # 2️⃣ Process default requirements (remaining text)
    default_reqs = parse_set_requirements(remaining)
    for vtype in vehicle_modes:
        for mode, reqs in default_reqs.items():
            vehicle_modes[vtype].setdefault(mode, set()).update(reqs)

    return vehicle_modes

if __name__ == "__main__":
    vehicle_modes = parse_requirements()

    # Convert sets to sorted lists for JSON output
    serializable = {
        vtype: {mode: sorted(list(reqs)) for mode, reqs in modes.items()}
        for vtype, modes in vehicle_modes.items()
    }

    print(json.dumps(serializable, indent=4))
