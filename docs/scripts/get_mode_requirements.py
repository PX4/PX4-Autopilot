#!/usr/bin/env python3
import re
from pathlib import Path
import json

"""
Parses mode requirements in https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/commander/ModeUtil/mode_requirements.cpp
The structure can then be used to generate docs.
This is mostly generated by ChatGPT, with some extensive prompting.


"""

# Define the meanings of each requirement
requirement_defns = dict()
requirement_defns['mode_req_angular_velocity'] = {'text': "Angular velocity", 'sensor': "gyroscope", "detail": "" }
requirement_defns['mode_req_attitude'] = {'text': "Attitude/pose", 'sensor': "IMU, or theoretically a motion capture system", "detail": ""}
requirement_defns['mode_req_local_position'] = {'text': "Position relative to EKF2 origin ('0') point", 'sensor': "GNSS, VIO, mocap", "detail": "" }
requirement_defns['mode_req_local_position_relaxed'] = {'text': "Position relative to EKF2 origin ('0') point but accepts poor accuracy", 'sensor': "Optical flow", "detail" : "Typically optical flow. You set zero when you take off and just integrate up the flow. So the absolute position can be very inaccurate but better than nothing. Useful to not drift away quickly and roughly know where you are." }
requirement_defns['mode_req_global_position'] = {'text': "Position measurement updates in a global coordinate frame", 'sensor': "GNSS, or local position and global reference to EKF 0", "detail": "" } 
requirement_defns['mode_req_global_position_relaxed'] = {'text': "Position measurement updates in a global coordinate frame but accepts poor accuracy", 'sensor': "", "detail": "Local position and global reference to EKF2 origin" } 
requirement_defns['mode_req_local_alt'] = {'text': "Local altitude relative to EKF2 origin ('0') position", 'sensor': "Barometer corrected by GNSS altitude over time, distance sensor", "detail": "Usually not the distance sensor because if the ground shifts then the coordinate frame would shift with it (range aid problem)."} 
requirement_defns['mode_req_mission'] = {'text': "Valid mission in autopilot's storage", 'sensor': "Mission mode only requirement", "detail": "can be from last time no need to upload fresh" } 
requirement_defns['mode_req_offboard_signal'] = {'text': "Offboard heartbeat", 'sensor': "", "detail": "MAVLink messages SET_ATTITUDE_TARGET or SET_POSITION_TARGET_LOCAL_NED or SET_POSITION_TARGET_GLOBAL_INT not timing out. Offboard mode specific requirement." }
requirement_defns['mode_req_home_position'] =  {'text': "Global home reference must be set", 'sensor': "", "detail": "Specific requirement for Return mode" } 
requirement_defns['mode_req_wind_and_flight_time_compliance'] = {'text': "Safety compliance limits on wind and flight time.", 'sensor': "", "detail": "Autonomous flight prevented in high winds (20m/s?) or if exceeds planned flight time, except for failsafe flight. See COM_FLT_TIME_MAX or COM_WIND_MAX for limits (also see COM_WIND_WARN, COM_WIND_MAX_ACT)." }
requirement_defns['mode_req_prevent_arming'] = {'text': "Mode prevents arming (vehicle must be armed to switch to this mode)", 'sensor': "", "detail": "Set for modes like Land, Orbit, Return that you can't take off in" } 
requirement_defns['mode_req_manual_control'] = {'text': "Requires stick input", 'sensor': "", "detail": "This can come from multiple channels: RC driver -> channels -> RC mapping/calibration -> [`manual_control_input` or `manual_control_setpoint` topic](../msg_docs/ManualControlSetpoint.md) -> Selector using [COM_RC_IN_MODE](../advanced_config/parameter_reference.md#COM_RC_IN_MODE) -> Joystick (MAVLink [MANUAL_CONTROL](https://mavlink.io/en/messages/common.html#MANUAL_CONTROL) message) -> ..." }
requirement_defns['mode_req_other'] = {'text': "Others requirement.", 'sensor': "",  "detail": "This is used by external modes. It is intended to specify additional requirements not covered by the existing flags"} 


# 1. Resolve the absolute path of the current script file.
script_path = Path(__file__).resolve()
# 2. Go up two directories from the script's location (docs/scripts/ -> PX4-Autopilot/).
# This finds the repository root.
repo_root = script_path.parent.parent.parent
# 3. Construct the target file path relative to the repository root.
SRC = repo_root / "src/modules/commander/ModeUtil/mode_requirements.cpp"

docs_output_path_base = repo_root / "docs/en/"
docs_output_path_flight_modes = docs_output_path_base / "flight_modes"


# Regex to find setRequirement(mode, requirement)
SET_REQ = re.compile(r"setRequirement\(\s*([^,]+)\s*,\s*([^)]+)\)")

# Original Regex to match the start of the specific if condition
VEH_IF_START = re.compile(
    r'if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*\{',
    re.MULTILINE,
)

# New Combined Regex Patterns
# 1. Pattern for specific IF-ELSE block (Group 1: Type, Group 2: If Body, Group 3: Else Body)
IF_ELSE_VEH = re.compile(
    # Start of the specific IF
    r'(?:^|\s)if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*'
    # IF Body (non-greedy)
    r'\{([\s\S]*?)\}\s*'
    # ELSE part
    r'else\s*\{([\s\S]*?)\}',
    re.MULTILINE | re.IGNORECASE
)

# 2. Pattern for specific STANDALONE IF block (Group 1: Type, Group 2: If Body)
IF_STANDALONE_VEH = re.compile(
    # Start of the specific IF
    r'(?:^|\s)if\s*\(\s*vehicle_type\s*==\s*vehicle_status_s::(VEHICLE_TYPE_[A-Z_]+)\s*\)\s*'
    # IF Body (non-greedy)
    r'\{([\s\S]*?)\}',
    re.MULTILINE | re.IGNORECASE
)


def extract_conditional_blocks(text):
    """
    Extracts specific if { … } blocks and optional else { … } following them
    using a two-step regex strategy.

    Returns:
        blocks: list of tuples (vehicle_type, if_block_text, else_block_text)
        remaining: text with conditional blocks removed (replaced by spaces)
    """
    blocks = []
    
    # --- 1. Find and process IF-ELSE blocks (Priority 1) ---
    
    # Use finditer to get matches and their spans to remove them later
    if_else_matches = list(IF_ELSE_VEH.finditer(text))
    
    # Process matches in reverse order to safely modify the code string
    for match in reversed(if_else_matches):
        vehicle_type = match.group(1)
        if_body = match.group(2).strip()
        else_body = match.group(3).strip()
        
        # else_block is not None here, but we pass None for consistency in the loop below
        blocks.append((vehicle_type, if_body, else_body))
        
        # Replace the matched block with whitespace to "remove" it
        start, end = match.span()
        text = text[:start] + ' ' * (end - start) + text[end:]

    # Reverse the list back to the original order of appearance
    blocks.reverse()


    # --- 2. Find and process STANDALONE IF blocks (Priority 2) ---

    # Note: text now contains only the code that was NOT part of an if-else block
    standalone_matches = list(IF_STANDALONE_VEH.finditer(text))
    
    # Process matches in reverse order
    for match in reversed(standalone_matches):
        vehicle_type = match.group(1)
        if_body = match.group(2).strip()
        
        # else_block is explicitly None for standalone ifs
        blocks.append((vehicle_type, if_body, None))
        
        # Replace the matched block with whitespace to "remove" it
        start, end = match.span()
        text = text[:start] + ' ' * (end - start) + text[end:]

    # Reverse the standalone block list back to the original order of appearance
    blocks[len(if_else_matches):].reverse()

    remaining = text
    return blocks, remaining


def parse_set_requirements(block_text):
    """
    Parse all setRequirement() calls in a text segment.
    Returns: dict of mode -> set(requirements)
    """
    results = {}
    for mode, req in SET_REQ.findall(block_text):
        mode = mode.strip().replace('vehicle_status_s::', '')
        req = req.strip().replace('flags.', '')
        results.setdefault(mode, set()).add(req)
    return results

def parse_requirements():
    # Attempt to read the file content
    try:
        text = SRC.read_text()
    except FileNotFoundError:
        print(f"Error: Source file not found at {SRC.resolve()}")
        # Returning an empty result for demonstration if file not found
        # In a real setup, you might want to raise the exception.
        return {} 

    # Extract getModeRequirements() body
    m = re.search(r"getModeRequirements\s*\([^)]*\)\s*\{(.*)\}", text, re.S)
    if not m:
        raise RuntimeError("Could not find getModeRequirements() body")
    body = m.group(1)

    # Extract conditional blocks using the new regex logic
    blocks, remaining = extract_conditional_blocks(body)

    # Determine all vehicle types seen in the code
    # Note: The code assumes all vehicle types relevant to the final output are
    # covered by the blocks and not just implicit.
    all_vehicle_types = set(vtype for vtype, _, _ in blocks)

    vehicle_modes = {vtype: {} for vtype in all_vehicle_types}

    # 1️⃣ Process conditional blocks
    for vtype, if_block, else_block in blocks:
        # Assign if-block requirements to the specified vehicle type
        reqs_if = parse_set_requirements(if_block)
        for mode, reqs in reqs_if.items():
            vehicle_modes[vtype].setdefault(mode, set()).update(reqs)

        # Assign else-block requirements to all other vehicle types
        if else_block:
            reqs_else = parse_set_requirements(else_block)
            # Find vehicle types NOT explicitly mentioned in the IF condition
            other_types = all_vehicle_types - {vtype}
            
            # The structure of the code assumes that 'else' applies to all other
            # vehicle types that appear in other blocks.
            for ot in other_types:
                for mode, reqs in reqs_else.items():
                    vehicle_modes[ot].setdefault(mode, set()).update(reqs)

    # 2️⃣ Process default requirements (remaining text)
    default_reqs = parse_set_requirements(remaining)
    for vtype in vehicle_modes:
        for mode, reqs in default_reqs.items():
            vehicle_modes[vtype].setdefault(mode, set()).update(reqs)

    return vehicle_modes

if __name__ == "__main__":


    vehicle_modes = parse_requirements()

    # Convert sets to sorted lists for JSON output - i.e. all reqs are listed in the same order.
    vehicle_modes_sorted = {
        vtype: {mode: sorted(list(reqs)) for mode, reqs in modes.items()}
        for vtype, modes in vehicle_modes.items()
    }

    print(json.dumps(vehicle_modes_sorted, indent=4))

    requirement_table = """
Requirement | Example
--- | ---
"""

    for requirement, info in requirement_defns.items():
        sensor_info = f" ({info['sensor']}) " if info['sensor'] else ''
        requirement_table += f"`{requirement}` | {info['text']}{sensor_info} <br><br>{info['detail']}\n"


    # Alternative heading experiment
    requirement_headings = ""

    for requirement, info in requirement_defns.items():
        sensor_info = f" ({info['sensor']}) " if info['sensor'] else ''
        requirement_headings += f"""
### {requirement}

{info['text']}{sensor_info} 

{info['detail']}
"""


    mode_requirements_markdown = f"""# Mode Requirements

Mode requirements define the set of conditions that must be met in order to arm in a particular flight mode, or to switch to the mode if it is already armed.

Requirements are defined for internal modes in [/src/modules/commander/ModeUtil/mode_requirements.cpp](https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/commander/ModeUtil/mode_requirements.cpp), and for ROS 2 external modes in [requirement_flags.hpp](https://github.com/Auterion/px4-ros2-interface-lib/blob/main/px4_ros2_cpp/include/px4_ros2/common/requirement_flags.hpp) (Github `Auterion/px4-ros2-interface-lib` repository).
The mode requirements are the same in both cases.

The following sections provide an overview of the requirements and what modes they are used in.

## Requirement definitions

{requirement_table} 

### Naming Conventions

In general requirement flag names are abstracted from specific sensors.
This is done because particular requirements can often be met by several sensors.
For example, GNSS is the most common source of global position, but it isn't the only one.

The requirements include frame and accuracy information hints in their names:
- `global` means an absolute world frame, such as that provided by GNSS.
- `local` means a frame that relative to an initialization point, such as the position of an IMU on boot.
- `relaxed` means that the mode does not require or rely on accurate data: as long as sensors are providing some data the state is considered valid.
  Relaxed conditions are used for modes where some sensor data is considered more important than none at all, such as when calculating position via optical flow velocity measurements.
  By contrast, a position mode that is not relaxed requires reliable sensor data, and will block arming if inaccuracy is detected.

Note that a global position requirement can be met if you have a valid _local position_, by mapping the local frame to a global position.
This can be done by setting the global position of the local origin using the MAVLink message [SET_GPS_GLOBAL_ORIGIN](https://mavlink.io/en/messages/common.html#SET_GPS_GLOBAL_ORIGIN), either directly or via a GCS (see [External Position Estimate > Enabling Auto Modes with a Local Position](../ros/external_position_estimation#enabling-auto-modes-with-a-local-position)).
Similarly, if the vehicle has `mode_req_local_position_relaxed`, then you can map to a global position in order to meet the `global_position_relaxed` requirement.
This allows PX4 automatic flight modes that require a global position to be used locally, such as Mission and Return.

<!-- 
## Requirement definitions

{requirement_headings}
--> 

    """



    for vehicle_type in vehicle_modes_sorted:
        if vehicle_type == 'VEHICLE_TYPE_ROTARY_WING':
            mode_requirements_markdown += f"\n## Multicopter ({vehicle_type})\n"
        elif vehicle_type == 'VEHICLE_TYPE_FIXED_WING':
            mode_requirements_markdown += f"\n## Fixed-wing ({vehicle_type})\n"
        else:    
            mode_requirements_markdown += f"\n## {vehicle_type}\n"


        for flight_mode in vehicle_modes_sorted[vehicle_type]:
            mode_heading_markdown = f"\n### {flight_mode}\n\n"
            if vehicle_type == 'VEHICLE_TYPE_ROTARY_WING':
                if flight_mode == 'NAVIGATION_STATE_AUTO_MISSION':
                    mode_heading_markdown = f"\n### [Mission Mode](../flight_modes_mc/mission.md) ({flight_mode})\n\n"
                elif flight_mode == 'NAVIGATION_STATE_AUTO_LOITER':
                    mode_heading_markdown = f"\n### [Hold Mode](../flight_modes_mc/hold.md) ({flight_mode})\n\n"
                elif flight_mode == 'NAVIGATION_STATE_AUTO_RTL':
                    mode_heading_markdown = f"\n### [Return Mode](../flight_modes_mc/return.md) ({flight_mode})\n\n"
                elif flight_mode == 'NAVIGATION_STATE_AUTO_TAKEOFF':
                    mode_heading_markdown = f"\n### [Takeoff Mode](../flight_modes_mc/takeoff.md) ({flight_mode})\n\n"

                    


            elif vehicle_type == 'VEHICLE_TYPE_FIXED_WING':
                if flight_mode == 'NAVIGATION_STATE_AUTO_MISSION':
                    mode_heading_markdown = f"\n### [Mission Mode](../flight_modes_fw/mission.md) ({flight_mode})\n\n"
                elif flight_mode == 'NAVIGATION_STATE_AUTO_LOITER':
                    mode_heading_markdown = f"\n### [Hold Mode](../flight_modes_fw/hold.md) ({flight_mode})\n\n"
                elif flight_mode == 'NAVIGATION_STATE_AUTO_RTL':
                    mode_heading_markdown = f"\n### [Return Mode](../flight_modes_fw/return.md) ({flight_mode})\n\n"          
                elif flight_mode == 'NAVIGATION_STATE_AUTO_TAKEOFF':
                    mode_heading_markdown = f"\n### [Takeoff Mode](../flight_modes_fw/takeoff.md) ({flight_mode})\n\n"



            mode_requirements_markdown += mode_heading_markdown

            for requirement in vehicle_modes_sorted[vehicle_type][flight_mode]:
                #mode_requirements_markdown += f"- {requirement}: {requirement_defns[requirement]}\n"
                mode_requirements_markdown += f"- {requirement}\n"


    # 2. Define the filename for the overview topic: mode_requirements
    filename = "mode_requirements.md"
    filename = docs_output_path_flight_modes / filename
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            # 'w' stands for 'write' mode, which creates the file or overwrites an existing one.
            f.write(mode_requirements_markdown)
        
        print(f"✅ Successfully wrote content to {filename}")

    except Exception as e:
        print(f"❌ An error occurred: {e}")


    # Generate per-doc mode requirements
    invalid_modes = ['mode_requirements_fixed_wing_position_slow.md',
                     'mode_requirements_fixed_wing_auto_vtol_takeoff.md',
                     'mode_requirements_fixed_wing_altitude_cruise.md',
                     'mode_requirements_fixed_wing_termination.md',
                     
                     'mode_requirements_rotary_wing_auto_precland.md',
                     'mode_requirements_rotary_wing_auto_vtol_takeoff.md',
                     'mode_requirements_rotary_wing_descend.md',
                     'mode_requirements_rotary_wing_manual.md',
                     'mode_requirements_rotary_wing_termination.md' ]

    for vehicle_type in vehicle_modes_sorted:
        for flight_mode in vehicle_modes_sorted[vehicle_type]:
            vehicle_part = vehicle_type.split("VEHICLE_TYPE_")[-1]
            mode_part = flight_mode.split("NAVIGATION_STATE_")[-1]

            if vehicle_part.startswith("FIXED_WING"):
                vehicle_path = "flight_modes_fw"
            elif vehicle_part.startswith("ROTARY_WING"):
                vehicle_path = "flight_modes_mc"
            else:
                print("UNKNOWN_VEHICLE_TYPE")
                exit()

            vehicle_mode_filename = f"mode_requirements_{vehicle_part}_{mode_part}.md".lower()

            vehicle_mode_filepath = docs_output_path_base / vehicle_path / vehicle_mode_filename
            print(f"Output: {vehicle_mode_filepath}")
            if vehicle_mode_filename in invalid_modes:
                print(f"❌ Mode {vehicle_mode_filename} doesn't map to flight mode")
                continue


            vehicle_mode_markdown = """### Mode Requirements

The following requirements must be met to arm in this mode, or to switch to this mode when it is armed.
            
"""

            for requirement in vehicle_modes_sorted[vehicle_type][flight_mode]:
                print(requirement)
                text = requirement_defns[requirement]['text']
                sensor = requirement_defns[requirement]['sensor']
                detail = requirement_defns[requirement]['detail']
                vehicle_mode_markdown += f"- [`{requirement}`](xxx) - {text}\n"
                #vehicle_mode_markdown += f"   - {detail}\n"

            try:
                with open(vehicle_mode_filepath, 'w', encoding='utf-8') as f:
                    # 'w' stands for 'write' mode, which creates the file or overwrites an existing one.
                    f.write(vehicle_mode_markdown)
                
                print(f"✅ Successfully wrote content to {vehicle_mode_filepath}")

            except Exception as e:
                print(f"❌ An error occurred: {e}")






