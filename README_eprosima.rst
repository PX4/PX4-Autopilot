PX4-FastRTPS
============

This is a fork of PX4 Firmware repository to add communication capabilities between a **PX4 Autopilot** (in this README we will talk about **PIXracer**) and a machine running **Fast RTPS** through serial ports using **CDR serialization**, aims to get information from a drone and carry to the DDS world through **Fast RTPS**.

.. image:: doc/1_general-white.png

Automatic code generation
-------------------------

The support for the new functionality added is mainly carried on inside three new (automatic generated) code blocks.

-  It's added a CDR serialization support directly on the original type support of the uORB topic adding a new interface to the code that do this directly. For *sensor_combined.msg* topic looks like this:

.. code-block:: shell

   void serialize_sensor_combined(const sensor_combined_s *input, char *output, uint32_t *length);

-  We have the capability under demand of the generation of an application to send through a selected UART the serializated info from the topic (*sensor_combined_uRTPS_UART_transmitter.cpp*).

.. image:: doc/2_trasnmitter-white.png

-  Now we also have the capacity of generate automatically the support for the other side of the communication, **Fast RTPS**. For the case of *sensor_combined* topic it's generated a class *sensor_combined_uRTPS_UART_receiver* and a *sensor_combined_.idl* file.

.. image:: doc/3_receiver-white.png

The code for extended topic support is generated within the normal PX4 Firmware generation process. The other will be generated under demand calling the new script **generate_microRTPS_support_general.py** placed in *Tools* folder, on this way:

.. code-block:: shell
    
    $ python Tools/generate_microRTPS_support_general.py [messages...]
    $ python Tools/generate_microRTPS_support_general.py msg/vehicle_status.msg msg/sensor_combined.msg
    
The output appear in the *msgenerated* folder, for this case:

.. code-block:: shell

    $ ls msgenerated/
    general_transmitter_CMakeLists.txt  
    general_uRTPS_UART_receiver.cxx  
    general_uRTPS_UART_transmitter.cpp  
    vehicle_status_.idl
    general_uRTPS_UART_PubSubMain.cxx   
    general_uRTPS_UART_receiver.h    
    sensor_combined_.idl

PX4 Firmware
------------

On the *PX4* side, it will be used an application running an uORB node. This node will be subscribed to a internal topic. The applications read the message in a loop, serializes the struct and writes it trough an UART port selected by the user.

Steps to use the auto generated application:

-  Uncomment in *cmake/configs/nuttx_px4fmu-v4_default.cmake* file the *#examples/micrortps_transmitter* to compile this appication along the **PX4** firmware:

.. code-block:: shell

    # eProsima app
    examples/micrortps_transmitter
    
-  Create a folder in *src/examples* and copy the above generated application inside:

.. code-block:: shell

   $ mkdir src/examples/micrortps_transmitter
   $ cp msgenerated/general_uRTPS_UART_transmitter.cpp src/examples/micrortps_transmitter

-  Also copy and rename the CMakeList to the example folder:

.. code-block:: shell

   $ cp msgenerated/general_transmitter_CMakeLists.txt src/examples/micrortps_transmitter/CMakeLists.txt
    
-  Construct and upload the firmware executing:

.. code-block:: shell

   $ make px4fmu-v4_default upload

After uploading the firmware, the application can be launched on *NuttShell* typing its name and passing an available serial port as argument. Using */dev/ttyACM0*
will use the USB port as output. Using */dev/ttyS1* or */dev/ttyS2* will write the output trough TELEM1 or TELEM2 ports respectively.

.. code-block:: shell

    > general_trans /dev/ttyACM0  #or /dev/ttySn

**NOTE**: If the UART port selected is busy, it's possible that Mavlink applications were using them. If it is the case, you can stop Mavlink from NuttShell typing:

.. code-block:: shell

    > mavlink stop-all

Fast RTPS (Raspberry PI application)
------------------------------------

The *Fast RTPS* side will be explained taking a *Raspberry Pi* board to run an application as example.

The application have two functions: get the sensor data from a system that is using the *PX4 Firmware* (reading the info from the selected UART) and publish it to a *Fast RTPS* environment.

Before runnning the application, it is needed to have installed Fast RTPS. Visit it installation `manual <http://eprosima-fast-rtps.readthedocs.io/en/latest/sources.html>`_ for more information.

This section explains how create *Fast RTPS* applications using the files generated by **generate_microRTPS_support_general.py** and **fastrtpsgen** from *Fast RTPS*.

This publisher-receiver application allow to launch a publisher that will be using the information coming from the uORB topic in the PX4 side thanks to the autogenerated idl file from the original msg file. The publisher will read data from the UART, deserializes it, and make a Fast RTPS message mapping the attributes from the uORB message. The subscriber simply receives the Fast RTPS messages and print them to the terminal. The subscriber can be launched on the Raspberry Pi or in any another device connected in the same network.

For create the application:

-  Create a folder and copy the generated files in this way:

.. code-block:: shell

    $ mkdir my_app && cd my_app
    $ cp /path/to/Firmware/msgenerated/*.idl .
    $ cp /path/to/Firmware/msgenerated/general_uRTPS_UART_receiver.* .

-  Generate the base application with *fastrtpsgen*:

.. code-block:: shell

    $ /path/to/Fast-RTPS/fastrtpsgen/scripts/fastrtpsgen -example x64Linux2.6gcc *.idl
    
-  Create a *lib* folder and move all the code except the *Main.cxx* files:

.. code-block:: shell

    $ mkdir lib
    $ mv *.cxx lib/ && mv *.h lib/
    $ mv lib/*Main.cxx .
     

-  Copy the generated code:

.. code-block:: shell

    $ cp /path/to/Firmware/msgenerated/general_uRTPS_UART_PubSubMain.cxx

    
Now we need to do some modifications to use the both codes together.
Add a publish method to all publisher on that way:

-  *sensor_combined_Publisher.h*

.. code-block:: shell

   @@ -35,7 +36,7 @@ class sensor_combined_Publisher
    public:
           sensor_combined_Publisher();
           virtual ~sensor_combined_Publisher();
           bool init();
           void run();
           void publish(sensor_combined_* st);
    private:
           Participant *mp_participant;
   

-  Add the publish-method to *sensor_combined_Publisher.cxx*

.. code-block:: shell

    void sensor_combined_Publisher::publish(sensor_combined_* st)
    {
      mp_publisher->write(st);
    }
    
-  The especific **PubSubMain.cxx* like *sensor_combined_PubSubMain.cxx* could be simplied like this:

.. code-block:: shell

   int main(int argc, char** argv)
   {
      cout << "Starting " << endl;
       sensor_combined_Subscriber mysub;
       if (mysub.init())
       {
           mysub.run();
       }
      
      return 0;
   }

-  In *sensor_combined_Subscriber.cxx* we can add some code to print some info on the screen, for example:

.. code-block:: shell

   void sensor_combined_Subscriber::SubListener::onNewDataMessage(Subscriber* sub)
   {
         // Take data
         sensor_combined_ sensor_data;
         
         if(sub->takeNextData(&sensor_data, &m_info))
         {
            if(m_info.sampleKind == ALIVE)
            {
                  cout << "\n\n\n\n\n\n\n\n\n\n";
                  cout << "Received sensor_combined data" << endl;
                  cout << "=============================" << endl;
                  cout << "timestamp: " << sensor_data.timestamp() << endl;
                  cout << "gyro_rad: " << sensor_data.gyro_rad().at(0);
                  cout << ", " << sensor_data.gyro_rad().at(1);
                  cout << ", " << sensor_data.gyro_rad().at(2) << endl;
                  cout << "gyro_integral_dt: " << sensor_data.gyro_integral_dt() << endl;
                  cout << "accelerometer_timestamp_relative: " << sensor_data.accelerometer_timestamp_relative() << endl;
                  cout << "accelerometer_m_s2: " << sensor_data.accelerometer_m_s2().at(0);
                  cout << ", " << sensor_data.accelerometer_m_s2().at(1);
                  cout << ", " << sensor_data.accelerometer_m_s2().at(2) << endl;
                  cout << "accelerometer_integral_dt: " << sensor_data.accelerometer_integral_dt() << endl;
                  cout << "magnetometer_timestamp_relative: " << sensor_data.magnetometer_timestamp_relative() << endl;
                  cout << "magnetometer_ga: " << sensor_data.magnetometer_ga().at(0);
                  cout << ", " << sensor_data.magnetometer_ga().at(1);
                  cout << ", " << sensor_data.magnetometer_ga().at(2) << endl;
                  cout << "baro_timestamp_relative: " << sensor_data.baro_timestamp_relative() << endl;
                  cout << "baro_alt_meter: " << sensor_data.baro_alt_meter() << endl;
                  cout << "baro_temp_celcius: " << sensor_data.baro_temp_celcius() << endl;
            }
         }
   }

- Adding a CMakeLists.txt. To generate the publisher-receiver and two different subscribers:

.. code-block:: shell

   cmake_minimum_required(VERSION 2.8.12)
   project(micrortps_receiver)
   
   # Find requirements
   find_package(fastrtps REQUIRED)
   find_package(fastcdr REQUIRED)
   
   
   # Set C++11
   include(CheckCXXCompilerFlag)
   if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANG OR
           CMAKE_CXX_COMPILER_ID MATCHES "Clang")
       check_cxx_compiler_flag(--std=c++11 SUPPORTS_CXX11)
       if(SUPPORTS_CXX11)
           add_compile_options(--std=c++11)
       else()
           message(FATAL_ERROR "Compiler doesn't support C++11")
       endif()
   endif()

   include_directories("lib")
   file(GLOB LIB_SOURCES lib/*.cxx)
   file(GLOB LIB_HEADERS lib/*.h)
   add_library(urtps_uart_recv ${LIB_SOURCES} ${LIB_HEADERS})
   target_link_libraries(urtps_uart_recv fastrtps fastcdr)

   add_executable(micrortps_receiver "general_uRTPS_UART_PubSubMain.cxx")
   target_link_libraries(micrortps_receiver urtps_uart_recv)

   add_executable(sensor_combined_subs "sensor_combined_PubSubMain.cxx")
   target_link_libraries(sensor_combined_subs urtps_uart_recv)

   add_executable(vehicle_status_subs "vehicle_status_PubSubMain.cxx")
   target_link_libraries(vehicle_status_subs urtps_uart_recv)
   
- Finally we compile the code:

.. code-block:: shell

   $ mkdir build && cd build
   $ cmake .. 
   $ make
   

Now, to launch the publisher run:

.. code-block:: shell

    $ ./micrortps_receiver /dev/ttyACM0 #or the selected UART

And, for launching the *sensor_combined* subscriber run:

.. code-block:: shell

    $ ./sensor_combined_subs

**NOTE**: Normally, it's necessary set up the UART port in the Raspberry Pi. To enable the serial port available on Raspberry Pi connector:

1. Make sure the userid (default is pi) is a member of the dialout group:

.. code-block:: shell

    $ groups pi
    $ sudo usermod -a -G dialout pi

2. You need to stop the already running on the GPIO serial console:

.. code-block:: shell

    $ sudo raspi-config

Go to *Interfacing options > Serial*, NO to *Would you like a login shell to be accessible over serial?*, valid and reboot.

3. Check UART in kernel:

.. code-block:: shell

   $ sudo vi /boot/config.txt

And enable UART setting *enable_uart=1*.

Result
------

The entire application will follow this flow chart:

.. image:: doc/architecture.png

If all steps has been followed, you should see this output on the subscriber side of Fast RTPS.

.. image:: doc/subscriber.png

A video of this final process as demostration is available on `https://youtu.be/NF65EPD-6aY <https://youtu.be/NF65EPD-6aY>`_